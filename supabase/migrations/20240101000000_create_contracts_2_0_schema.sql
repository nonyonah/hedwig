-- =====================================================
-- Contracts 2.0 Schema Migration
-- =====================================================
-- This migration creates all tables, indexes, policies, and functions
-- needed for the Contracts 2.0 system
-- =====================================================

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =====================================================
-- TABLES
-- =====================================================

-- Legal contracts table for storing AI-generated contract text
CREATE TABLE IF NOT EXISTS legal_contracts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  project_title TEXT NOT NULL,
  project_description TEXT,
  client_id UUID REFERENCES auth.users(id),
  client_name TEXT NOT NULL,
  client_email TEXT,
  client_wallet TEXT NOT NULL,
  freelancer_id UUID REFERENCES auth.users(id),
  freelancer_name TEXT NOT NULL,
  freelancer_email TEXT,
  freelancer_wallet TEXT NOT NULL,
  payment_amount DECIMAL(20, 6) NOT NULL,
  token_type TEXT NOT NULL DEFAULT 'USDC',
  chain TEXT NOT NULL DEFAULT 'base',
  deadline TIMESTAMPTZ NOT NULL,
  milestones JSONB,
  refund_policy TEXT,
  contract_text TEXT NOT NULL,
  contract_hash TEXT NOT NULL UNIQUE,
  status TEXT NOT NULL DEFAULT 'generated' CHECK (status IN (
    'generated',    -- Contract generated by AI
    'approved',     -- Approved by client
    'deployed',     -- Smart contract deployed
    'active',       -- Contract is active
    'completed',    -- Contract completed
    'cancelled'     -- Contract cancelled
  )),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  approved_at TIMESTAMPTZ,
  deployed_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Contracts table for managing contract lifecycle
CREATE TABLE IF NOT EXISTS contracts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  client_id UUID REFERENCES auth.users(id),
  freelancer_id UUID REFERENCES auth.users(id),
  client_email TEXT,
  title TEXT NOT NULL,
  description TEXT,
  total_amount NUMERIC NOT NULL,
  amount_paid NUMERIC DEFAULT 0,
  token_type TEXT NOT NULL DEFAULT 'USDC',
  chain TEXT NOT NULL DEFAULT 'base',
  token_address TEXT,
  deadline TIMESTAMPTZ,
  status TEXT NOT NULL DEFAULT 'pending',
  approval_token TEXT UNIQUE,
  decline_reason TEXT,
  legal_contract_id UUID REFERENCES legal_contracts(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  approved_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ
);

-- Contract milestones table
CREATE TABLE IF NOT EXISTS contract_milestones (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  contract_id UUID NOT NULL REFERENCES contracts(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  amount NUMERIC NOT NULL,
  due_date TIMESTAMPTZ,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
    'pending',     -- Milestone is pending completion
    'completed',   -- Milestone work is completed
    'paid'         -- Milestone has been paid
  )),
  invoice_id UUID,
  payment_hash TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ
);

-- Contract invoices table
CREATE TABLE IF NOT EXISTS contract_invoices (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  contract_id UUID NOT NULL REFERENCES contracts(id) ON DELETE CASCADE,
  milestone_id UUID REFERENCES contract_milestones(id),
  invoice_number TEXT UNIQUE NOT NULL,
  amount NUMERIC NOT NULL,
  token_type TEXT NOT NULL,
  chain TEXT NOT NULL,
  token_address TEXT,
  client_wallet TEXT,
  freelancer_wallet TEXT,
  status TEXT NOT NULL DEFAULT 'pending',
  payment_hash TEXT,
  payment_confirmed_at TIMESTAMPTZ,
  due_date TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Contract notifications table
CREATE TABLE IF NOT EXISTS contract_notifications (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  contract_id UUID NOT NULL REFERENCES contracts(id) ON DELETE CASCADE,
  recipient TEXT NOT NULL, -- 'client', 'freelancer', or 'system'
  notification_type TEXT NOT NULL, -- 'approval_request', 'approved', 'declined', 'milestone_completed', etc.
  subject TEXT NOT NULL,
  message TEXT NOT NULL,
  sent_via_email BOOLEAN DEFAULT false,
  sent_via_telegram BOOLEAN DEFAULT false,
  sent_at TIMESTAMPTZ,
  read_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- =====================================================
-- INDEXES
-- =====================================================

-- Legal contracts indexes
CREATE INDEX IF NOT EXISTS idx_legal_contracts_client_id ON legal_contracts(client_id);
CREATE INDEX IF NOT EXISTS idx_legal_contracts_freelancer_id ON legal_contracts(freelancer_id);
CREATE INDEX IF NOT EXISTS idx_legal_contracts_client_email ON legal_contracts(client_email);
CREATE INDEX IF NOT EXISTS idx_legal_contracts_freelancer_email ON legal_contracts(freelancer_email);
CREATE INDEX IF NOT EXISTS idx_legal_contracts_status ON legal_contracts(status);
CREATE INDEX IF NOT EXISTS idx_legal_contracts_chain ON legal_contracts(chain);
CREATE INDEX IF NOT EXISTS idx_legal_contracts_created_at ON legal_contracts(created_at);
CREATE INDEX IF NOT EXISTS idx_legal_contracts_contract_hash ON legal_contracts(contract_hash);

-- Contracts indexes
CREATE INDEX IF NOT EXISTS idx_contracts_client_id ON contracts(client_id);
CREATE INDEX IF NOT EXISTS idx_contracts_freelancer_id ON contracts(freelancer_id);
CREATE INDEX IF NOT EXISTS idx_contracts_status ON contracts(status);
CREATE INDEX IF NOT EXISTS idx_contracts_approval_token ON contracts(approval_token);
CREATE INDEX IF NOT EXISTS idx_contracts_created_at ON contracts(created_at);
CREATE INDEX IF NOT EXISTS idx_contracts_client_email ON contracts(client_email);

-- Contract milestones indexes
CREATE INDEX IF NOT EXISTS idx_contract_milestones_contract_id ON contract_milestones(contract_id);
CREATE INDEX IF NOT EXISTS idx_contract_milestones_status ON contract_milestones(status);
CREATE INDEX IF NOT EXISTS idx_contract_milestones_due_date ON contract_milestones(due_date);

-- Contract invoices indexes
CREATE INDEX IF NOT EXISTS idx_contract_invoices_contract_id ON contract_invoices(contract_id);
CREATE INDEX IF NOT EXISTS idx_contract_invoices_milestone_id ON contract_invoices(milestone_id);
CREATE INDEX IF NOT EXISTS idx_contract_invoices_status ON contract_invoices(status);
CREATE INDEX IF NOT EXISTS idx_contract_invoices_invoice_number ON contract_invoices(invoice_number);

-- Contract notifications indexes
CREATE INDEX IF NOT EXISTS idx_contract_notifications_contract_id ON contract_notifications(contract_id);
CREATE INDEX IF NOT EXISTS idx_contract_notifications_recipient ON contract_notifications(recipient);
CREATE INDEX IF NOT EXISTS idx_contract_notifications_sent_at ON contract_notifications(sent_at);

-- =====================================================
-- ROW LEVEL SECURITY POLICIES
-- =====================================================

-- Enable RLS on all tables
ALTER TABLE legal_contracts ENABLE ROW LEVEL SECURITY;
ALTER TABLE contracts ENABLE ROW LEVEL SECURITY;
ALTER TABLE contract_milestones ENABLE ROW LEVEL SECURITY;
ALTER TABLE contract_invoices ENABLE ROW LEVEL SECURITY;
ALTER TABLE contract_notifications ENABLE ROW LEVEL SECURITY;

-- Legal contracts policies
CREATE POLICY "Users can view legal contracts they're involved in" ON legal_contracts
  FOR SELECT USING (
    client_id = auth.uid() OR 
    freelancer_id = auth.uid() OR
    freelancer_email = auth.jwt() ->> 'email' OR 
    client_email = auth.jwt() ->> 'email'
  );

CREATE POLICY "Service can manage all legal contracts" ON legal_contracts
  FOR ALL USING (true);

-- Contracts policies
CREATE POLICY "Users can view their own contracts" ON contracts
  FOR SELECT USING (
    client_id = auth.uid() OR 
    freelancer_id = auth.uid()
  );

CREATE POLICY "Users can update their own contracts" ON contracts
  FOR UPDATE USING (
    client_id = auth.uid() OR 
    freelancer_id = auth.uid()
  );

-- Contract milestones policies
CREATE POLICY "Users can view milestones for their contracts" ON contract_milestones
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM contracts 
      WHERE id = contract_milestones.contract_id 
      AND (client_id = auth.uid() OR freelancer_id = auth.uid())
    )
  );

CREATE POLICY "Users can update milestones for their contracts" ON contract_milestones
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM contracts 
      WHERE id = contract_milestones.contract_id 
      AND (client_id = auth.uid() OR freelancer_id = auth.uid())
    )
  );

-- Contract invoices policies
CREATE POLICY "Users can view invoices for their contracts" ON contract_invoices
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM contracts 
      WHERE id = contract_invoices.contract_id 
      AND (client_id = auth.uid() OR freelancer_id = auth.uid())
    )
  );

-- Contract notifications policies
CREATE POLICY "Users can view their contract notifications" ON contract_notifications
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM contracts 
      WHERE id = contract_notifications.contract_id 
      AND (client_id = auth.uid() OR freelancer_id = auth.uid())
    )
  );

-- =====================================================
-- FUNCTIONS
-- =====================================================

-- Function to get token address based on type and chain
CREATE OR REPLACE FUNCTION get_token_address(token_type TEXT, chain TEXT)
RETURNS TEXT AS $$
BEGIN
  CASE 
    WHEN token_type = 'USDC' AND chain = 'base' THEN
      RETURN '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';
    WHEN token_type = 'USDC' AND chain = 'ethereum' THEN
      RETURN '0xA0b86a33E6441E6C8D3C1C4C9C8C6C8C6C8C6C8C';
    WHEN token_type = 'ETH' AND chain = 'ethereum' THEN
      RETURN '0x0000000000000000000000000000000000000000';
    WHEN token_type = 'ETH' AND chain = 'base' THEN
      RETURN '0x4200000000000000000000000000000000000006';
    ELSE
      RETURN NULL;
  END CASE;
END;
$$ LANGUAGE plpgsql;

-- Function to update contract updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- TRIGGERS
-- =====================================================

-- Updated_at triggers
CREATE TRIGGER update_legal_contracts_updated_at
  BEFORE UPDATE ON legal_contracts
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_contracts_updated_at
  BEFORE UPDATE ON contracts
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_contract_milestones_updated_at
  BEFORE UPDATE ON contract_milestones
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_contract_invoices_updated_at
  BEFORE UPDATE ON contract_invoices
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- PERMISSIONS
-- =====================================================

-- Grant permissions to authenticated users
GRANT SELECT, INSERT, UPDATE ON legal_contracts TO authenticated;
GRANT SELECT, INSERT, UPDATE ON contracts TO authenticated;
GRANT SELECT, INSERT, UPDATE ON contract_milestones TO authenticated;
GRANT SELECT, INSERT, UPDATE ON contract_invoices TO authenticated;
GRANT SELECT, INSERT, UPDATE ON contract_notifications TO authenticated;

-- Grant usage on sequences
GRANT USAGE ON ALL SEQUENCES IN SCHEMA public TO authenticated;

-- =====================================================
-- VIEWS
-- =====================================================

-- Contract summary view
CREATE OR REPLACE VIEW contract_summary AS
SELECT 
  c.id,
  c.title,
  c.description,
  c.total_amount,
  c.amount_paid,
  c.token_type,
  c.chain,
  c.status,
  c.deadline,
  c.created_at,
  c.updated_at,
  c.approved_at,
  c.completed_at,
  -- Client info
  client.email as client_email,
  client.raw_user_meta_data->>'name' as client_name,
  -- Freelancer info  
  freelancer.email as freelancer_email,
  freelancer.raw_user_meta_data->>'name' as freelancer_name,
  -- Milestone stats
  COUNT(cm.id) as total_milestones,
  COUNT(CASE WHEN cm.status = 'completed' THEN 1 END) as completed_milestones,
  COUNT(CASE WHEN cm.status = 'paid' THEN 1 END) as paid_milestones,
  -- Next due date
  MIN(CASE WHEN cm.status = 'pending' THEN cm.due_date END) as next_due_date,
  -- Progress percentage
  CASE 
    WHEN COUNT(cm.id) = 0 THEN 0
    ELSE ROUND((COUNT(CASE WHEN cm.status = 'completed' THEN 1 END)::NUMERIC / COUNT(cm.id)::NUMERIC) * 100, 2)
  END as progress_percentage
FROM contracts c
LEFT JOIN auth.users client ON c.client_id = client.id
LEFT JOIN auth.users freelancer ON c.freelancer_id = freelancer.id
LEFT JOIN contract_milestones cm ON c.id = cm.contract_id
GROUP BY 
  c.id, c.title, c.description, c.total_amount, c.amount_paid, 
  c.token_type, c.chain, c.status, c.deadline, c.created_at, 
  c.updated_at, c.approved_at, c.completed_at,
  client.email, client.raw_user_meta_data->>'name',
  freelancer.email, freelancer.raw_user_meta_data->>'name';

-- Grant permissions on the view
GRANT SELECT ON contract_summary TO authenticated;